
#include <slua/State.hpp>

#include <slua/Exception.hpp>

#include <cstdlib>

//Lua Includes
extern "C" {
    #include <lua.h>
    #include <lauxlib.h>
    #include <lualib.h>
}

using namespace slua;


/**
* Creates a new State
*/
State::State()
    : state_(lua_newstate(&State::lua_alloc, this)),
	  ctx_(state_)
{
    luaL_openlibs(state_);
    
    //lua_State *lua_newstate (lua_Alloc f, void *ud);

    //register panic function:
	//lua_atpanic
	//lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
	//using debugger?
	
	//typedef void * (*lua_Alloc) (void *ud, void *ptr, size_t osize, size_t nsize);
	
	//lua_Alloc lua_getallocf (lua_State *L, void **ud);
}

/**
* Destructor
*/
State::~State()
{
    lua_close(state_);
    state_ = nullptr;
}

/**
* Load a file
*/
void State::LoadFile(const char* file)
{
    int status = luaL_loadfile(state_, file);
    if (status)
    {
        throw LuaFormatException("Error loading file: %s", lua_tostring(state_, -1));
    }
}

/**
* Execute Lua Scripts
*/
int State::Execute()
{
	int r = lua_pcall(state_, 0, LUA_MULTRET, 0);
	
    
    //LUA_OK (0): success.
    //LUA_ERRRUN: a runtime error.
    //LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the message handler.
    //LUA_ERRERR: error while running the message handler.
    //LUA_ERRGCMM: error while running a __gc metamethod. (This error typically has no relation with the function being called. It is generated by the garbage collector.)
    
    if(r == LUA_ERRRUN)
    {
		throw LuaFormatException("Error executing: %s", lua_tostring(state_, -1));
	}
	
	if(r == LUA_ERRGCMM)
	{
		throw LuaFormatException("Error executing: %s", lua_tostring(state_, -1));
	}
	
    return r;
}

State* State::getState(lua_State* state)
{
	void* stateptr;
	lua_getallocf (state, &stateptr);
	if(stateptr)
		return static_cast<State*>(stateptr);
	else
		return nullptr;
}

void* State::lua_alloc(void *ud, void *ptr, size_t osize, size_t nsize)
{
	(void)ud;  
	(void)osize;  

	if (nsize == 0) 
	{
		free(ptr);
		return NULL;
	}
	else
		return realloc(ptr, nsize);
}




/*
Sets a new panic function and returns the old one.
If an error happens outside any protected environment, Lua calls a panic function and then calls exit(EXIT_FAILURE), thus exiting the host application. Your panic function can avoid this exit by never returning (e.g., doing a long jump).
The panic function can access the error message at the top of the stack. 
*/
