
#include <slua/State.hpp>

#include <slua/Exception.hpp>

//Lua Includes
extern "C" {
    #include <lua.h>
    #include <lauxlib.h>
    #include <lualib.h>
}

using namespace slua;


/**
* Creates a new State
*/
State::State()
    : state_(luaL_newstate()),
	  ctx_(state_)
{
    luaL_openlibs(state_);
    
    //lua_State *lua_newstate (lua_Alloc f, void *ud);

    //register panic function:
	//lua_atpanic
	//lua_CFunction lua_atpanic (lua_State *L, lua_CFunction panicf);
	//using debugger?
}

/**
* Destructor
*/
State::~State()
{
    lua_close(state_);
    state_ = nullptr;
}

/**
* Load a file
*/
void State::LoadFile(const char* file)
{
    int status = luaL_loadfile(state_, file);
    if (status)
    {
        throw LuaFormatException("Error loading file: %s", lua_tostring(state_, -1));
    }
}

/**
* Execute Lua Scripts
*/
int State::Execute()
{
	int r = lua_pcall(state_, 0, LUA_MULTRET, 0);
	
    
    //LUA_OK (0): success.
    //LUA_ERRRUN: a runtime error.
    //LUA_ERRMEM: memory allocation error. For such errors, Lua does not call the message handler.
    //LUA_ERRERR: error while running the message handler.
    //LUA_ERRGCMM: error while running a __gc metamethod. (This error typically has no relation with the function being called. It is generated by the garbage collector.)
    
    if(r == LUA_ERRRUN)
    {
		throw LuaFormatException("Error executing: %s", lua_tostring(state_, -1));
	}
	
	if(r == LUA_ERRGCMM)
	{
		throw LuaFormatException("Error executing: %s", lua_tostring(state_, -1));
	}
	
    return r;
}




/*
Sets a new panic function and returns the old one.
If an error happens outside any protected environment, Lua calls a panic function and then calls exit(EXIT_FAILURE), thus exiting the host application. Your panic function can avoid this exit by never returning (e.g., doing a long jump).
The panic function can access the error message at the top of the stack. 
*/
